---
title: "[python] list1[:0]=string ?"
date: 2021-06-07 00:00:00
categories:
  - python
tags: [python]
---



Python은 List를 인덱스로 범위를 지정해 잘라낼 수 있습니다. 사용해 보신 분들은 다들 아시겠지만 리스트 슬라이싱은 기존 List에 덮어씌워지지 않고 새로운 List가 생성되는 방식입니다.

```python
arr = [1, 2, 3, 4, 5]
sliced_arr = arr[1:3]
print(arr)
print(sliced_arr)
# [1, 2, 3, 4, 5]
# [2, 3]
```



그리고 리스트 슬라이싱은 다음과 같은 문법을 가지고 있습니다.

```python
array[start:end:step]
```

- start : 시작 인덱스, 0번을 지정할 시 맨 앞이 시작입니다.
- end : 끝 인덱스
- step : 슬라이싱의 interval, 간격을 몇칸을 둘 것인지?

여기까지는 리스트 슬라이싱을 알고 계신 분들이라면 기본적으로 알고 있는 내용일거라 생각합니다.

그런데 링크드인 Python Developers Community에서 [이 질문](https://www.linkedin.com/feed/update/urn:li:activity:6807257421052960768)을 보고 리스트 슬라이싱에 대해서 좀 더 자세히 알고 싶어졌습니다. 이런 내용인데요.

```python
def Convert(string):
  list1=[]
  list1[:0]=string
  return list1

str1 = 'ABCD'
print(Convert(str1))

# ['A', 'B', 'C', 'D']
# How it worked like this?
```

 저 리스트 슬라이싱이 어떻게 동작하는지 설명하고 싶었고,

- 리스트 슬라이싱이 새로운 리스트를 반환한다
- 인덱싱된 리스트에 string을 할당하니 리스트 형태로 들어갔다

이 2가지를 나름대로 단계를 거치며 왜 이런건지 생각을 해봤습니다. 그렇기 때문에 아래에 기술하는 내용은 물론 정확한 사실은 아니고, 제 생각입니다.

<br/>

# 리스트 슬라이싱은 새로운 리스트를 반환한다

맞습니다. 리스트 슬라이싱은 새로운 리스트를 반환합니다. id를 출력해보면 명확히 알 수 있습니다. 위에서도 언급했듯 대부분 리스트 슬라이싱은 이렇게 슬라이싱한 리스트를 새로운 변수에 할당해 사용합니다.

```python
arr = [1, 2, 3, 4]
sliced = arr[1:3]
print(f'arr id : {id(arr)}, arr : {arr}')
print(f'sliced id : {id(sliced)}, sliced : {sliced}')

# arr id : 4562963136, arr : [1, 2, 3, 4]
# sliced id : 4562960768, sliced : [2, 3]
```



그런데 링크드인 질문글에 올라온 건 반대입니다. 슬라이싱된 리스트에 string을 할당하고 있습니다.

```python
list1[:0]=string
```



이걸 이해하기 위해서, Convert 함수를 조금 고쳐보겠습니다.

```python
def Convert(string):
  list1=['1', '2', '3']
  list1[:0]=string
  return list1

str1 = 'ABCD'
print(Convert(str1))
# ['A', 'B', 'C', 'D', '1', '2', '3']
```

위 결과를 보면 다음과 같이 유추할 수 있습니다.

- 리스트 슬라이싱을 하려고 지정한 인덱스에

- 지정한 string이 list 형태로 변환되어

- 들어갔다

  

리스트 슬라이싱을 새로운 리스트의 반환이 아니라 해당 위치에 값을 할당한다는 개념으로 바라본다면, 이런 가정도 가능합니다.

-  리스트는 가변적인 Object이다(mutable)
- list1[:0]=string 단계가 리스트의 지정된 위치에 값을 할당하는 것이라면, 이 단계가 지나도 기존 객체로 계속 남아있을 것이다. 



그렇다면 id를 찍어보겠습니다.

```python
def Convert(string):
  list1=['1', '2', '3']
  print("====== list1[:0]=string 전 ======")
  print(id(list1))
  print(list1)
  print()
  list1[:0]=string
  print("====== list1[:0]=string 후 ======")
  print(id(list1))
  print(list1)
  print()
  print("====== list1[:] ======")
  print(id(list1[:]))
  return list1

str1 = 'ABCD'
print(Convert(str1))

"""
====== list1[:0]=string 전 ======
4314755456
['1', '2', '3']

====== list1[:0]=string 후 ======
4314755456
['A', 'B', 'C', 'D', '1', '2', '3']

====== list1[:] ======
4314757824
['A', 'B', 'C', 'D', '1', '2', '3']
"""


```

`list1[:0] = string` 이후에도 id가 변하지 않았습니다. `list1[:0] = string`은 `list1[0] = string`처럼 리스트에 정해진 위치에 값을 추가할 뿐 리스트 자체를 새로운 객체로 반환하지 않았습니다. 

`list1[:0] = string` 은 리스트 슬라이싱으로 보는게 아니라 리스트 인덱싱으로 보는 것이 더 적절하겠습니다.

<br/>

# 인덱싱된 리스트에 string을 할당하니 리스트 형태로 들어갔다

리스트가 할당된 객체에 string을 다시 할당하면 그 객체는 str 타입이 되어버립니다.

```python
list_obj = [1, 2, 3]
list_obj = 'ABC'
print(type(list_obj))
# <class 'str'>
```



그런데 인덱싱된 리스트에 string을 할당하면 string이 아니라 각 원소가 list 형태로 분리된채로 들어갑니다.

```python
list_obj = [1, 2, 3]
list_obj[0:1] = 'ABC'
print(type(list_obj))
# <class 'list'>

print(list_obj)
# ['A', 'B', 'C', 2, 3]
```



string이 아닌 int를 할당하려하면 다음과 같은 에러를 만나게 됩니다.

```python
list_obj = [1, 2, 3]
list_obj[:0] = 1
"""
Traceback (most recent call last):
  File "<input>", line 1, in <module>
TypeError: can only assign an iterable
"""
```



list를 넣을 수 있을까요?

```python
list_obj[:0] = ['a', 'b']
print(list_obj)
# ['a', 'b', 1, 2, 3]
```

가능합니다.

그렇다면 여기에서는 다음과 같은 사실을 알 수 있습니다.

- 슬라이싱된 리스트에는 iterable 객체만 들어갈 수 있다.
- 슬라이싱된 리스트에는 iterable한 객체의 원소가 iterate되어 들어간다.



이제...이것만 알면 될 것 같습니다.

- 왜 슬라이싱된 리스트에 할당하는 iterable 객체는 단일 객체가 아니라 리스트 형태로 들어가는가

<br/>

# 왜 슬라이싱된 리스트에 할당하는 iterable 객체는 단일 객체가 아니라 리스트 형태로 들어가는가

바로 위에서 썼던 코드를 보겠습니다.

```python
list_obj[:0] = 'AB'
```

이 코드의 의미를 보이는대로 풀어보자면 이렇습니다.

**list_obj의 [0번째부터 0번째까지] 'AB'를 할당해라**



그런데 결과와 해석이 동일하려면 위 해석에는 하나가 더 추가되어야 합니다.

**list_obj의 [0번째부터 0번째까지] 'AB'를 _하나씩_ 할당해라**



단순히 하나의 인덱스를 가지고 위치를 지정한다면 iterable 객체가 리스트의 n번째 원소로 할당되어 버립니다.

```python
list_obj = [1, 2, 3]
list_obj[1] = 'AB'
print(list_obj)
# [1, 'AB', 3]
```



그러나 슬라이싱으로 위치를 지정한다면 iterable 객체는 그 상태로 리스트에 n개가 할당되어 버립니다. 슬라이싱으로 인덱스 1개만큼만을 가져와도 그렇습니다.

```python
list_obj = [1, 2, 3]
list_obj[1:2] = 'AB'
print(list_obj)
# [1, 'A', 'B', 3]
```



여기까지 알게 된 사실을 종합해보면 이런 가설을 유추할 수 있습니다. 이것만 왜 이런지 확인한다면 `list1[:0]='ABCD'`  -> `['A', 'B', 'C', 'D']` 도 자연스럽게 이해할 수 있습니다.

- 특정 범위가 지정된 메모리 공간에 할당되는 값은 iterable한 객체라면 iterable하게 할당된다.



다음 포스팅에서는 파이썬 빌드인 코드와 공식문서를 근거로 해서 확인을 해보겠습니다.









