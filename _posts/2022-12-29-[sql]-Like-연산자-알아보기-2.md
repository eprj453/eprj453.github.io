---
title: "[sql] Like 연산자 알아보기"
date: 2022-12-19 00:00:00
categories:
- sql
tags: [sql, data]

---

like 연산자는 왼쪽 %과 오른쪽 %이 다르다는 것, 그리고 이런 검색 방식을 개선하기 위해 tokenize 방식의 전문 인덱스 개념이 나왔고 ES와 같은 검색 엔진도 같은 개념에서 출발했다는 것을 보았습니다.

그렇다면 인덱스가 없는 DW, 제가 현업에서 사용하고 있는 redshift를 예로 들어 어떤 식으로 like의 성능개선을 해볼 수 있을지 생각해보겠습니다.

<br/>

# distkey, sortkey

redshift의 최적화에서 필수로 고려해야할 분산키(distkey)와 정렬키(sortkey)입니다. 

- 분산키는 hash function의 인자가 되기 때문에, 각 노드에 고루 분산될 수 있도록 중복이 적고 균일하게 분산되어 있는 컬럼을 설정해주는 것이 좋습니다. unique한 id나 timestamp를 주로 사용합니다.

  > https://docs.aws.amazon.com/redshift/latest/dg/c_Distribution_examples.html

- 범위 스캔을 자주 사용하는 경우, 정렬키를 잘 설정하는 것이 효율에 도움이 됩니다. 정렬이 잘 되어 있는 경우에는 단일 블록 I/O를 상당수 건너뛰고 원하는 범위만을 스캔할 수 있습니다. order by 성능 뿐만 아니라 group by의 범위를 줄여줄 수 있습니다. 앞선 포스팅의 랜덤 I/O를 줄이는 방법 중 하나라고 보면 되겠습니다. 공식 문서에서는 SORTKEY AUTO로 두고 사용할 것을 권장하고 있으나, 등록일자 등 unique한 날짜 컬럼을 sortkey로 사용하면 성능향상에 도움이 될 수 있습니다.

  > https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html



그렇다면 like를 스캔하는 컬럼을 distkey나 sortkey로 설정했을때 도움이 될까요? 제 생각에는 큰 성능향상을 보이긴 어려울것 같습니다. 

distkey부터 보면,

1.  검색하는 내용이 주로 상품명인데, 상품명이 distkey로 그다지 좋은 옵션은 아니라는 생각이 듭니다. unique할 확률이 높긴 하지만 컬럼의 값이 균일하게 분배될 것이라고도 보장하기 어려운, user_id나 timestamp와 같이 어떤 형태, 어떤 값으로 들어올 것이다라는 예측이 어려운 컬럼이기 때문입니다.
2. 여러 노드에 잘 분산되는 것과 like의 성능향상 자체가 큰 관련이 있을것 같지 않습니다. 결국 둘 다 full scan을 한다는 점에서 distkey의 역할이 크지 않을것이라 봅니다.

sortkey도 보겠습니다.

1. 범위를 특정할 수 있게 된다는 점에서 스캔 범위를 줄이는데 도움이 될 수 있으나, 이 방식이 `%단어%` 형태의 양쪽 like 검색을 효율적으로 만들어주지는 못합니다. 



결국, redshift에서 key를 지정해 like의 성능향상을 바라기는 어렵다는 결론에 도달했고, 테스트 결과에서도 distkey / sortkey를 지정한 테이블이 더 나은 query plan을 보여주지 않았습니다.

<br/>

# redshift에서 like 성능 향상

결국 랜덤 I/O를 줄이자!라는 쿼리 튜닝의 본질에서 벗어날 수 없었습니다. redshift AQUA라는 캐시 기반의 쿼리 성능 향상기능이 출시되어 like / similar to 연산자의 성능을 대폭 향상시킬 수 있으나 이는 기능일 뿐이기 때문에 여기서는 배제했습니다.

> https://aws.amazon.com/ko/blogs/korea/new-aqua-advanced-query-accelerator-for-amazon-redshift/
>
> AQUA는 `LIKE` 및 `SIMILAR_TO` 조건자를 사용하여 대규모 검색, 집계 및 필터링을 수행하는 쿼리에 대해 최대 10배의 성능을 제공하도록 설계되었습니다. 시간이 지남에 따라 추가 쿼리에 대한 지원이 추가될 것으로 예상됩니다.



줄일 수 있는 I/O를 분석해 실제로 어느정도 성능이 향상되는지 알아보겠습니다.













# 참고

https://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning

[친절한 SQL 튜닝](http://www.yes24.com/Product/Goods/61254539) - 조시형 저

https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html















